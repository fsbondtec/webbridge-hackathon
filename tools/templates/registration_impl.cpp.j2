/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by webbridge Registration Generator
 * Source: {{ header_path }}
 * 
 * IMPLEMENTATION FILE - Compiled separately to reduce compile times
 */

#include "{{ cls.name }}_registration.h"
#include "{{ header_path }}"
#include "webbridge/impl/object_registry.h"
#include "webbridge/impl/binding_helpers.h"
#include "webbridge/impl/dispatcher.h"
#include "webbridge/impl/type_registration.h"
#include <nlohmann/json.hpp>

{% if cls.enums -%}
// =============================================================================
// JSON Serialization for Nested Enums (implementations)
// =============================================================================

{% for enum in cls.enums -%}
static void to_json(nlohmann::json& j, const {{ cls.name }}::{{ enum.name }}& e) {
    switch (e) {
{% for value in enum.enum_values %}
        case {{ cls.name }}::{{ enum.name }}::{{ value }}: j = "{{ value }}"; break;
{% endfor %}
        default: j = nullptr; break;
    }
}

static void from_json(const nlohmann::json& j, {{ cls.name }}::{{ enum.name }}& e) {
    const auto& name = j.get<std::string>();
{% for value in enum.enum_values %}
    {{ "if" if loop.first else "else if" }} (name == "{{ value }}") e = {{ cls.name }}::{{ enum.name }}::{{ value }};
{% endfor %}
    else {
        throw nlohmann::json::type_error::create(
            302,
            "Invalid enum value: '" + name + "' for type {{ cls.name }}::{{ enum.name }}",
            nullptr
        );
    }
}

{% endfor -%}
{% endif -%}
namespace webbridge::impl {

// =============================================================================
// Internal Implementation (static linkage)
// =============================================================================

static void setup_subscriptions_impl(
    webview::webview& w_ref,
    const std::string& object_id,
    {{ cls.name }}* obj)
{
{% for prop in cls.properties %}
    subscribe_property(w_ref, object_id, "{{ prop.name }}", obj->{{ prop.name }});
{% endfor %}
{% for evt in cls.events %}
    subscribe_event(w_ref, object_id, "{{ evt.name }}", obj->{{ evt.name }});
{% endfor -%}
}

// =============================================================================
// Handler Functions (static linkage - only used via function pointers)
// =============================================================================

static void setup_{{ cls.name }}_subscriptions(
    webview::webview& w_ref,
    const std::string& object_id,
    void* obj_ptr)
{
    setup_subscriptions_impl(w_ref, object_id, static_cast<{{ cls.name }}*>(obj_ptr));
}

static void handle_{{ cls.name }}_sync(
    webview::webview& w_ref,
    object_registry& registry,
    const std::string& req_id,
    const std::string& object_id,
    const std::string& op,
    const std::string& member,
    const nlohmann::json& args)
{
    auto obj = get_object_or_throw<{{ cls.name }}>(registry, object_id);

    if (op == "prop") {
{% for prop in cls.properties %}
        {{ "if" if loop.first else "} else if" }} (member == "{{ prop.name }}") {
            w_ref.resolve(req_id, 0, nlohmann::json(obj->{{ prop.name }}()).dump());
            return;
{% endfor %}
{% if cls.properties %}
        }
{% endif %}
    } else if (op == "const") {
{% for const in cls.constants if not const.is_static %}
        {{ "if" if loop.first else "} else if" }} (member == "{{ const.name }}") {
            w_ref.resolve(req_id, 0, nlohmann::json(obj->{{ const.name }}).dump());
            return;
{% endfor %}
{% if cls.constants | selectattr('is_static', 'false') | list %}
        }
{% endif %}
    } else if (op == "call") {
{% for method in cls.sync_methods %}
        {{ "if" if loop.first else "} else if" }} (member == "{{ method.name }}") {
            auto [status, json] = invoke_and_serialize(
                "{{ cls.name }}::{{ method.name }}",
                [&]() {
{% if method.parameters %}
                    return obj->{{ method.name }}(
{% for param in method.parameters %}
                        args.at({{ loop.index0 + 4 }}).get<{{ cls | qualified_type(param[0]) }}>(){% if not loop.last %},{% endif %}

{% endfor %}
                    );
{% else %}
                    return obj->{{ method.name }}();
{% endif %}
                }
            );
            w_ref.resolve(req_id, status, json);
            return;
{% endfor %}
{% if cls.sync_methods %}
        }
{% endif %}
    }
    // Unknown member/op
    w_ref.resolve(req_id, 1, R"({"error": "Unknown member or operation: )" + op + "/" + member + R"("})");
}

static void handle_{{ cls.name }}_async(
    webview::webview& w_ref,
    object_registry& registry,
    const std::string& req_id,
    const std::string& object_id,
    const std::string& method,
    const nlohmann::json& args)
{
{% if cls.async_methods %}
    auto obj = get_object_or_throw<{{ cls.name }}>(registry, object_id);

{% for method in cls.async_methods %}
    {{ "if" if loop.first else "} else if" }} (method == "{{ method.name }}") {
        auto [status, json] = invoke_and_serialize(
            "{{ cls.name }}::{{ method.name }}",
            [&]() {
{% if method.parameters %}
                return obj->{{ method.name }}(
{% for param in method.parameters %}
                    args.at({{ loop.index0 + 3 }}).get<{{ cls | qualified_type(param[0]) }}>(){% if not loop.last %},{% endif %}

{% endfor %}
                );
{% else %}
                return obj->{{ method.name }}();
{% endif %}
            }
        );
        w_ref.resolve(req_id, status, json);
        return;
{% endfor %}
    }
    // Unknown method
    w_ref.resolve(req_id, 1, R"({"error": "Unknown async method: )" + method + R"("})");
{% else %}
    // No async methods defined
    (void)registry; (void)object_id; (void)method; (void)args;
    w_ref.resolve(req_id, 1, R"({"error": "No async methods defined for {{ cls.name }}"})");
{% endif %}
}

static std::string handle_{{ cls.name }}_create(
    webview::webview& w_ref,
    object_registry& registry,
    const nlohmann::json& args)
{
{% set ctor = cls.constructors[0] if cls.constructors else none %}
{% if ctor and ctor.parameters %}
    auto obj = std::make_shared<{{ cls.name }}>(
{% for param in ctor.parameters %}
        args[{{ loop.index0 }}].get<{{ cls | qualified_type(param[0]) }}>(){% if not loop.last %},{% endif %}

{% endfor %}
    );
{% else %}
    (void)args;
    auto obj = std::make_shared<{{ cls.name }}>();
{% endif %}
    auto object_id = registry.register_object(obj, "{{ cls.name }}");
    setup_subscriptions_impl(w_ref, object_id, obj.get());
    return object_id;
}

void register_{{ cls.name }}(webview::webview* w) {
    webview::webview& w_ref = *w;
    using namespace impl;
    auto& registry = object_registry::instance();

    // Initialize webview with dispatcher bindings (once per webview instance)
    init_webview(w, [&registry](const std::string& object_id) {
        registry.remove(object_id);
    });

    register_class_handler(
        "{{ cls.name }}",
        handle_{{ cls.name }}_sync,
        handle_{{ cls.name }}_async,
        handle_{{ cls.name }}_create
    );

    // Static constants as JSON object
    nlohmann::json static_consts = nlohmann::json::object();
{% for const in cls.constants if const.is_static %}
    static_consts["{{ const.name }}"] = {{ cls.name }}::{{ const.name }};
{% endfor %}

    // JS class initialization (uses universal dispatcher functions)
    w_ref.init(generate_js_class_wrapper(
        "{{ cls.name }}",
        {{ cls.sync_methods | json_names }},
        {{ cls.async_methods | json_names }},
        {{ cls.properties | json_names }},
        {{ cls.events | json_names }},
        {{ cls.constants | selectattr('is_static', 'false') | list | json_names }},
        static_consts
    ));
}

} // namespace webbridge::impl
