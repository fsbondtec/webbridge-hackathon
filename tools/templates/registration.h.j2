#pragma once

/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by webbridge Registration Generator
 * Source: {{ header_path }}
 */

#include <nlohmann/json.hpp>

#include "webbridge/impl/object_registry.h"
#include "webbridge/impl/type_registration.h"
#include "webbridge/impl/binding_helpers.h"
#include "{{ header_path }}"

namespace webbridge {

// =============================================================================
// Static Validations
// =============================================================================

static_assert(impl::is_webbridge_object<{{ cls.name }}>,
              "{{ cls.name }} must derive from webbridge::object");

{% for prop in cls.properties -%}
static_assert(std::is_same_v<decltype({{ cls.name }}::{{ prop.name }}), object::property<{{ prop.type_name }}>>);
{% endfor -%}
{% for evt in cls.events -%}
static_assert(std::is_same_v<decltype({{ cls.name }}::{{ evt.name }}), object::event<{{ evt.arg_types | join(', ') }}>>);
{% endfor %}

// =============================================================================
// Type-specific Setup
// =============================================================================

namespace impl {

inline void setup_subscriptions(
    webview::webview& w_ref,
    const std::string& object_id,
    std::shared_ptr<{{ cls.name }}> obj)
{
    // Properties
{% for prop in cls.properties %}
    subscribe_property<{{ cls.name }}>(w_ref, object_id, "{{ prop.name }}", obj->{{ prop.name }});
{% endfor %}
    // Events
{% for evt in cls.events %}
    subscribe_event<{{ cls.name }}>(w_ref, object_id, "{{ evt.name }}", obj->{{ evt.name }});
{% endfor -%}
}

inline void bind_all(webview::webview& w_ref, object_registry& registry)
{
    // Property Getters
{% for prop in cls.properties %}
    bind_property_getter<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ prop.name }}", &{{ cls.name }}::{{ prop.name }});
{% endfor %}
    // Sync Methods
{% for method in cls.sync_methods %}
    bind_sync_method<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ method.name }}", &{{ cls.name }}::{{ method.name }});
{% endfor %}
    // Async Methods
{% for method in cls.async_methods %}
    bind_async_method<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ method.name }}", &{{ cls.name }}::{{ method.name }});
{% endfor -%}
}

} // namespace impl

// =============================================================================
// Template Specializations
// =============================================================================

template<>
inline void register_type<{{ cls.name }}>(webview::webview* w) {
    webview::webview& w_ref = *w;
    using namespace impl;
    auto& registry = object_registry::instance();

    // JS initialization
    w_ref.init(generate_js_global_registry());
    w_ref.init(generate_js_class_wrapper(
        "{{ cls.name }}",
        {{ cls.sync_methods | json_names }},
        {{ cls.async_methods | json_names }},
        {{ cls.properties | json_names }},
        {{ cls.events | json_names }}
    ));

    // Object creation
    w_ref.bind("__create_{{ cls.name }}", [&registry, &w_ref](const std::string& req) -> std::string {
        auto obj = std::make_shared<{{ cls.name }}>();
        auto object_id = registry.register_object(obj, "{{ cls.name }}");
        impl::setup_subscriptions(w_ref, object_id, obj);
        return nlohmann::json(object_id).dump();
    });

    // Object destruction
    w_ref.bind("__webbridge_destroy", [&registry](const std::string& req) -> std::string {
        auto args = nlohmann::json::parse(req);
        registry.remove(extract_object_id(args));
        return "null";
    });

    // All bindings
    impl::bind_all(w_ref, registry);
}

template<>
inline void publish_object<{{ cls.name }}>(webview::webview* w, std::string_view name, std::shared_ptr<{{ cls.name }}> obj) {
    webview::webview& w_ref = *w;
    using namespace impl;
    auto& registry = object_registry::instance();
    auto object_id = registry.register_object(obj, "{{ cls.name }}");

    impl::setup_subscriptions(w_ref, object_id, obj);

    w_ref.init(generate_js_published_object(
        "{{ cls.name }}",
        std::string(name),
        object_id,
        {{ cls.sync_methods | json_names }},
        {{ cls.async_methods | json_names }},
        {{ cls.properties | json_names }},
        {{ cls.events | json_names }}
    ));
}

} // namespace webbridge