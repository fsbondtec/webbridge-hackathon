#pragma once

/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by webbridge Registration Generator
 * Source: {{ header_path }}
 * 
 * DISPATCHER VERSION: Uses central dispatcher instead of per-class bind() calls.
 * This reduces startup time from O(nÂ²) to O(n) for multiple classes.
 */

#include <nlohmann/json.hpp>
#include <chrono>
#include <iostream>
#include <thread>

#include "webbridge/impl/object_registry.h"
#include "webbridge/impl/type_registration.h"
#include "webbridge/impl/binding_helpers.h"
#include "webbridge/impl/dispatcher.h"
#include "{{ header_path }}"

{% if cls.enums -%}
// =============================================================================
// JSON Serialization for Nested Enums
// =============================================================================

{% for enum in cls.enums -%}
inline void to_json(nlohmann::json& j, const {{ cls.name }}::{{ enum.name }}& e) {
    switch (e) {
{% for value in enum.enum_values %}
        case {{ cls.name }}::{{ enum.name }}::{{ value }}: j = "{{ value }}"; break;
{% endfor %}
        default: j = nullptr; break;
    }
}

inline void from_json(const nlohmann::json& j, {{ cls.name }}::{{ enum.name }}& e) {
    const auto& name = j.get<std::string>();
{% for value in enum.enum_values %}
    {{ "if" if loop.first else "else if" }} (name == "{{ value }}") e = {{ cls.name }}::{{ enum.name }}::{{ value }};
{% endfor %}
    else {
        throw nlohmann::json::type_error::create(
            302,
            "Invalid enum value: '" + name + "' for type {{ cls.name }}::{{ enum.name }}",
            nullptr
        );
    }
}

{% endfor -%}
{% endif -%}
namespace webbridge {

// =============================================================================
// Static Validations
// =============================================================================

static_assert(impl::is_webbridge_object<{{ cls.name }}>,
              "{{ cls.name }} must derive from webbridge::object");


// =============================================================================
// Type-specific Setup
// =============================================================================

namespace impl {

inline void setup_subscriptions(
    webview::webview& w_ref,
    const std::string& object_id,
    {{ cls.name }}* obj)
{
{% for prop in cls.properties %}
    subscribe_property(w_ref, object_id, "{{ prop.name }}", obj->{{ prop.name }});
{% endfor %}
{% for evt in cls.events %}
    subscribe_event(w_ref, object_id, "{{ evt.name }}", obj->{{ evt.name }});
{% endfor -%}
}

// =============================================================================
// Dispatcher Handlers for {{ cls.name }}
// =============================================================================

// Sync handler: handles property gets, constant gets, and sync method calls
inline void handle_{{ cls.name }}_sync(
    webview::webview& w_ref,
    object_registry& registry,
    const std::string& req_id,
    const std::string& object_id,
    const std::string& op,
    const std::string& member,
    const nlohmann::json& args)
{
    auto obj = get_object_or_throw<{{ cls.name }}>(registry, object_id);

    if (op == "prop") {
{% for prop in cls.properties %}
        {{ "if" if loop.first else "} else if" }} (member == "{{ prop.name }}") {
            w_ref.resolve(req_id, 0, nlohmann::json(obj->{{ prop.name }}()).dump());
            return;
{% endfor %}
{% if cls.properties %}
        }
{% endif %}
    } else if (op == "const") {
{% for const in cls.constants if not const.is_static %}
        {{ "if" if loop.first else "} else if" }} (member == "{{ const.name }}") {
            w_ref.resolve(req_id, 0, nlohmann::json(obj->{{ const.name }}).dump());
            return;
{% endfor %}
{% if cls.constants | selectattr('is_static', 'false') | list %}
        }
{% endif %}
    } else if (op == "call") {
{% for method in cls.sync_methods %}
        {{ "if" if loop.first else "} else if" }} (member == "{{ method.name }}") {
            auto [status, json] = invoke_and_serialize([&]() {
{% if method.parameters %}
                return obj->{{ method.name }}(
{% for param in method.parameters %}
                    args.at({{ loop.index0 + 4 }}).get<{{ cls | qualified_type(param[0]) }}>(){% if not loop.last %},{% endif %}

{% endfor %}
                );
{% else %}
                return obj->{{ method.name }}();
{% endif %}
            });
            w_ref.resolve(req_id, status, json);
            return;
{% endfor %}
{% if cls.sync_methods %}
        }
{% endif %}
    }
    // Unknown member/op
    w_ref.resolve(req_id, 1, R"({"error": "Unknown member or operation: )" + op + "/" + member + R"("})");
}

// Async handler: handles async method calls (runs in background thread)
inline void handle_{{ cls.name }}_async(
    webview::webview& w_ref,
    object_registry& registry,
    const std::string& req_id,
    const std::string& object_id,
    const std::string& method,
    const nlohmann::json& args)
{
{% if cls.async_methods %}
    auto obj = get_object_or_throw<{{ cls.name }}>(registry, object_id);

{% for method in cls.async_methods %}
    {{ "if" if loop.first else "} else if" }} (method == "{{ method.name }}") {
        auto [status, json] = invoke_and_serialize([&]() {
{% if method.parameters %}
            return obj->{{ method.name }}(
{% for param in method.parameters %}
                args.at({{ loop.index0 + 3 }}).get<{{ cls | qualified_type(param[0]) }}>(){% if not loop.last %},{% endif %}

{% endfor %}
            );
{% else %}
            return obj->{{ method.name }}();
{% endif %}
        });
        w_ref.resolve(req_id, status, json);
        return;
{% endfor %}
    }
    // Unknown method
    w_ref.resolve(req_id, 1, R"({"error": "Unknown async method: )" + method + R"("})");
{% else %}
    // No async methods defined
    (void)registry; (void)object_id; (void)method; (void)args;
    w_ref.resolve(req_id, 1, R"({"error": "No async methods defined for {{ cls.name }}"})");
{% endif %}
}

// Create handler: creates new instance and returns object_id
inline std::string handle_{{ cls.name }}_create(
    webview::webview& w_ref,
    object_registry& registry,
    const nlohmann::json& args)
{
{% set ctor = cls.constructors[0] if cls.constructors else none %}
{% if ctor and ctor.parameters %}
    auto obj = std::make_shared<{{ cls.name }}>(
{% for param in ctor.parameters %}
        args[{{ loop.index0 }}].get<{{ cls | qualified_type(param[0]) }}>(){% if not loop.last %},{% endif %}

{% endfor %}
    );
{% else %}
    (void)args;
    auto obj = std::make_shared<{{ cls.name }}>();
{% endif %}
    auto object_id = registry.register_object(obj, "{{ cls.name }}");
    setup_subscriptions(w_ref, object_id, obj.get());
    return object_id;
}

// Register all handlers for {{ cls.name }} in the dispatcher
inline void register_{{ cls.name }}_handlers() {
    register_class_handler(
        "{{ cls.name }}",
        handle_{{ cls.name }}_sync,
        handle_{{ cls.name }}_async,
        handle_{{ cls.name }}_create
    );
}

} // namespace impl

// =============================================================================
// Template Specializations
// =============================================================================

template<>
inline void register_type<{{ cls.name }}>(webview::webview* w) {
    webview::webview& w_ref = *w;
    using namespace impl;
    auto& registry = object_registry::instance();

    // Initialize webview with dispatcher bindings (once per webview instance)
    // This creates only 4 bind() calls total instead of 3 per class!
    init_webview(w, [&registry](const std::string& object_id) {
        registry.remove(object_id);
    });

    // Register handlers in the dispatcher (no bind() calls!)
    register_{{ cls.name }}_handlers();

    // Static constants as JSON object
    nlohmann::json static_consts = nlohmann::json::object();
{% for const in cls.constants if const.is_static %}
    static_consts["{{ const.name }}"] = {{ cls.name }}::{{ const.name }};
{% endfor %}

    // JS class initialization (uses universal dispatcher functions)
    w_ref.init(generate_js_class_wrapper(
        "{{ cls.name }}",
        {{ cls.sync_methods | json_names }},
        {{ cls.async_methods | json_names }},
        {{ cls.properties | json_names }},
        {{ cls.events | json_names }},
        {{ cls.constants | selectattr('is_static', 'false') | list | json_names }},
        static_consts
    ));
}

} // namespace webbridge

