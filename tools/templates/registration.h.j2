#pragma once

/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by webbridge Registration Generator
 * Source: {{ header_path }}
 */

#include <nlohmann/json.hpp>
#include <chrono>
#include <iostream>

#include "webbridge/impl/object_registry.h"
#include "webbridge/impl/type_registration.h"
#include "webbridge/impl/binding_helpers.h"
#include "{{ header_path }}"

{% if cls.enums -%}
// =============================================================================
// JSON Serialization for Nested Enums
// =============================================================================

{% for enum in cls.enums -%}
inline void to_json(nlohmann::json& j, const {{ cls.name }}::{{ enum.name }}& e) {
    switch (e) {
{% for value in enum.enum_values %}
        case {{ cls.name }}::{{ enum.name }}::{{ value }}: j = "{{ value }}"; break;
{% endfor %}
        default: j = nullptr; break;
    }
}

inline void from_json(const nlohmann::json& j, {{ cls.name }}::{{ enum.name }}& e) {
    const auto& name = j.get<std::string>();
{% for value in enum.enum_values %}
    {{ "if" if loop.first else "else if" }} (name == "{{ value }}") e = {{ cls.name }}::{{ enum.name }}::{{ value }};
{% endfor %}
    else {
        throw nlohmann::json::type_error::create(
            302,
            "Invalid enum value: '" + name + "' for type {{ cls.name }}::{{ enum.name }}",
            nullptr
        );
    }
}

{% endfor -%}
{% endif -%}
namespace webbridge {

// =============================================================================
// Static Validations
// =============================================================================

static_assert(impl::is_webbridge_object<{{ cls.name }}>,
              "{{ cls.name }} must derive from webbridge::object");


// =============================================================================
// Type-specific Setup
// =============================================================================

namespace impl {

inline void setup_subscriptions(
    webview::webview& w_ref,
    const std::string& object_id,
    std::shared_ptr<{{ cls.name }}> obj)
{
    // Properties
{% for prop in cls.properties %}
    subscribe_property<{{ cls.name }}>(w_ref, object_id, "{{ prop.name }}", obj->{{ prop.name }});
{% endfor %}
    // Events
{% for evt in cls.events %}
    subscribe_event<{{ cls.name }}>(w_ref, object_id, "{{ evt.name }}", obj->{{ evt.name }});
{% endfor -%}
}

inline void bind_all(webview::webview& w_ref, object_registry& registry)
{
    auto start_total = std::chrono::high_resolution_clock::now();
    
    // Property Getters
    {
        auto start = std::chrono::high_resolution_clock::now();
{% for prop in cls.properties %}
        bind_property_getter<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ prop.name }}", &{{ cls.name }}::{{ prop.name }});
{% endfor %}
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::high_resolution_clock::now() - start);
        std::cout << "[Timing] bind_all property getters: " << elapsed.count() << " ms" << std::endl;
    }
    
    // Instance Constant Getters
    {
        auto start = std::chrono::high_resolution_clock::now();
{% for const in cls.constants if not const.is_static %}
        bind_instance_constant_getter<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ const.name }}", &{{ cls.name }}::{{ const.name }});
{% endfor %}
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::high_resolution_clock::now() - start);
        std::cout << "[Timing] bind_all instance constants: " << elapsed.count() << " ms" << std::endl;
    }
    
    // Static Constants
    {
        auto start = std::chrono::high_resolution_clock::now();
{% for const in cls.constants if const.is_static %}
        define_static_constant(w_ref, "{{ cls.name }}", "{{ const.name }}", {{ cls.name }}::{{ const.name }});
{% endfor %}
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::high_resolution_clock::now() - start);
        std::cout << "[Timing] bind_all static constants: " << elapsed.count() << " ms" << std::endl;
    }
    
    // Sync Methods
    {
        auto start = std::chrono::high_resolution_clock::now();
{% for method in cls.sync_methods %}
        bind_sync_method<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ method.name }}", &{{ cls.name }}::{{ method.name }});
{% endfor %}
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::high_resolution_clock::now() - start);
        std::cout << "[Timing] bind_all sync methods: " << elapsed.count() << " ms" << std::endl;
    }
    
    // Async Methods
    {
        auto start = std::chrono::high_resolution_clock::now();
{% for method in cls.async_methods %}
        bind_async_method<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ method.name }}", &{{ cls.name }}::{{ method.name }});
{% endfor %}
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::high_resolution_clock::now() - start);
        std::cout << "[Timing] bind_all async methods: " << elapsed.count() << " ms" << std::endl;
    }
    
    auto elapsed_total = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::high_resolution_clock::now() - start_total);
    std::cout << "[Timing] bind_all total: " << elapsed_total.count() << " ms" << std::endl;
}

} // namespace impl

// =============================================================================
// Template Specializations
// =============================================================================

template<>
inline void register_type<{{ cls.name }}>(webview::webview* w) {
    auto start_register = std::chrono::high_resolution_clock::now();
    webview::webview& w_ref = *w;
    using namespace impl;
    auto& registry = object_registry::instance();

    // JS initialization
    {
        auto start = std::chrono::high_resolution_clock::now();
        w_ref.init(generate_js_global_registry());
        w_ref.init(generate_js_class_wrapper(
            "{{ cls.name }}",
            {{ cls.sync_methods | json_names }},
            {{ cls.async_methods | json_names }},
            {{ cls.properties | json_names }},
            {{ cls.events | json_names }},
            {{ cls.constants | selectattr('is_static', 'false') | list | json_names }},
            {{ cls.constants | selectattr('is_static') | list | json_names }}
        ));
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::high_resolution_clock::now() - start);
        std::cout << "[Timing] register_type JS initialization: " << elapsed.count() << " ms" << std::endl;
    }

    // Object creation
{% set ctor = cls.constructors[0] if cls.constructors else none %}
    {
        auto start = std::chrono::high_resolution_clock::now();
        w_ref.bind("__create_{{ cls.name }}", [&registry, &w_ref](const std::string& req) -> std::string {
{% if ctor and ctor.parameters %}
            auto args = nlohmann::json::parse(req);
            auto obj = std::make_shared<{{ cls.name }}>(
{% for param in ctor.parameters %}
                args[{{ loop.index0 }}].get<{{ param[0] }}>(){% if not loop.last %},{% endif %}

{% endfor %}
            );
{% else %}
            auto obj = std::make_shared<{{ cls.name }}>();
{% endif %}
            auto object_id = registry.register_object(obj, "{{ cls.name }}");
            impl::setup_subscriptions(w_ref, object_id, obj);
            return nlohmann::json(object_id).dump();
        });
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::high_resolution_clock::now() - start);
        std::cout << "[Timing] register_type object creation binding: " << elapsed.count() << " ms" << std::endl;
    }

    // Object destruction
    {
        auto start = std::chrono::high_resolution_clock::now();
        w_ref.bind("__webbridge_destroy", [&registry](const std::string& req) -> std::string {
            auto args = nlohmann::json::parse(req);
            registry.remove(extract_object_id(args));
            return "null";
        });
        auto elapsed = std::chrono::duration_cast<std::chrono::milliseconds>(
            std::chrono::high_resolution_clock::now() - start);
        std::cout << "[Timing] register_type object destruction binding: " << elapsed.count() << " ms" << std::endl;
    }

    // All bindings
    impl::bind_all(w_ref, registry);
    
    auto elapsed_total = std::chrono::duration_cast<std::chrono::milliseconds>(
        std::chrono::high_resolution_clock::now() - start_register);
    std::cout << "[Timing] register_type total: " << elapsed_total.count() << " ms" << std::endl;
}

template<>
inline void publish_object<{{ cls.name }}>(webview::webview* w, std::string_view name, std::shared_ptr<{{ cls.name }}> obj) {
    webview::webview& w_ref = *w;
    using namespace impl;
    auto& registry = object_registry::instance();
    auto object_id = registry.register_object(obj, "{{ cls.name }}");

    impl::setup_subscriptions(w_ref, object_id, obj);

    w_ref.init(generate_js_published_object(
        "{{ cls.name }}",
        std::string(name),
        object_id,
        {{ cls.sync_methods | json_names }},
        {{ cls.async_methods | json_names }},
        {{ cls.properties | json_names }},
        {{ cls.events | json_names }},
        {{ cls.constants | selectattr('is_static', 'false') | list | json_names }},
        {{ cls.constants | selectattr('is_static') | list | json_names }}
    ));
}

} // namespace webbridge