#pragma once

/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by webbridge Registration Generator
 * Source: {{ header_path }}
 */

#include <nlohmann/json.hpp>

#include "webbridge/Impl/ObjectRegistry.h"
#include "webbridge/Impl/TypeRegistration.h"
#include "webbridge/Impl/BindingHelpers.h"
#include "{{ header_path }}"

namespace webbridge {

// =============================================================================
// Static Validations
// =============================================================================

static_assert(Impl::IsWebBridgeObject<{{ cls.name }}>,
              "{{ cls.name }} must derive from webbridge::Object");

{% for prop in cls.properties -%}
static_assert(std::is_same_v<decltype({{ cls.name }}::{{ prop.name }}), Object::Property<{{ prop.type_name }}>>);
{% endfor -%}
{% for evt in cls.events -%}
static_assert(std::is_same_v<decltype({{ cls.name }}::{{ evt.name }}), Object::Event<{{ evt.arg_types | join(', ') }}>>);
{% endfor %}

// =============================================================================
// Type-specific Setup
// =============================================================================

namespace Impl {

inline void setupSubscriptions(
    webview::webview& wRef,
    const std::string& objectId,
    std::shared_ptr<{{ cls.name }}> obj)
{
    // Properties
{% for prop in cls.properties %}
    subscribeProperty<{{ cls.name }}>(wRef, objectId, "{{ prop.name }}", obj->{{ prop.name }});
{% endfor %}
    // Events
{% for evt in cls.events %}
    subscribeEvent<{{ cls.name }}>(wRef, objectId, "{{ evt.name }}", obj->{{ evt.name }});
{% endfor -%}
}

inline void bindAll(webview::webview& wRef, ObjectRegistry& registry)
{
    // Property Getters
{% for prop in cls.properties %}
    bindPropertyGetter<{{ cls.name }}>(wRef, registry, "{{ cls.name }}", "{{ prop.name }}", &{{ cls.name }}::{{ prop.name }});
{% endfor %}
    // Sync Methods
{% for method in cls.sync_methods %}
    bindSyncMethod<{{ cls.name }}>(wRef, registry, "{{ cls.name }}", "{{ method.name }}", &{{ cls.name }}::{{ method.name }});
{% endfor %}
    // Async Methods
{% for method in cls.async_methods %}
    bindAsyncMethod<{{ cls.name }}>(wRef, registry, "{{ cls.name }}", "{{ method.name }}", &{{ cls.name }}::{{ method.name }});
{% endfor -%}
}

} // namespace Impl

// =============================================================================
// Template Specializations
// =============================================================================

template<>
inline void registerType<{{ cls.name }}>(webview::webview* w) {
    webview::webview& wRef = *w;
    using namespace Impl;
    auto& registry = ObjectRegistry::instance();

    // JS initialization
    wRef.init(generateJsGlobalRegistry());
    wRef.init(generateJsClassWrapper(
        "{{ cls.name }}",
        {{ cls.sync_methods | json_names }},
        {{ cls.async_methods | json_names }},
        {{ cls.properties | json_names }},
        {{ cls.events | json_names }}
    ));

    // Object creation
    wRef.bind("__create_{{ cls.name }}", [&registry, &wRef](const std::string& req) -> std::string {
        auto obj = std::make_shared<{{ cls.name }}>();
        auto objectId = registry.registerObject(obj, "{{ cls.name }}");
        Impl::setupSubscriptions(wRef, objectId, obj);
        return nlohmann::json(objectId).dump();
    });

    // Object destruction
    wRef.bind("__webbridge_destroy", [&registry](const std::string& req) -> std::string {
        auto args = nlohmann::json::parse(req);
        registry.remove(extractObjectId(args));
        return "null";
    });

    // All bindings
    Impl::bindAll(wRef, registry);
}

template<>
inline void publishObject<{{ cls.name }}>(webview::webview* w, std::string_view name, std::shared_ptr<{{ cls.name }}> obj) {
    webview::webview& wRef = *w;
    using namespace Impl;
    auto& registry = ObjectRegistry::instance();
    auto objectId = registry.registerObject(obj, "{{ cls.name }}");

    Impl::setupSubscriptions(wRef, objectId, obj);

    wRef.init(generateJsPublishedObject(
        "{{ cls.name }}",
        std::string(name),
        objectId,
        {{ cls.sync_methods | json_names }},
        {{ cls.async_methods | json_names }},
        {{ cls.properties | json_names }},
        {{ cls.events | json_names }}
    ));
}

} // namespace webbridge