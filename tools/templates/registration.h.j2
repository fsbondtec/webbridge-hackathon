#pragma once

/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by webbridge Registration Generator
 * Source: {{ header_path }}
 */

#include <nlohmann/json.hpp>

#include "webbridge/impl/object_registry.h"
#include "webbridge/impl/type_registration.h"
#include "webbridge/impl/binding_helpers.h"
#include "{{ header_path }}"

{% if cls.enums -%}
// =============================================================================
// JSON Serialization for Nested Enums
// =============================================================================

{% for enum in cls.enums -%}
inline void to_json(nlohmann::json& j, const {{ cls.name }}::{{ enum.name }}& e) {
    switch (e) {
{% for value in enum.enum_values %}
        case {{ cls.name }}::{{ enum.name }}::{{ value }}: j = "{{ value }}"; break;
{% endfor %}
        default: j = nullptr; break;
    }
}

inline void from_json(const nlohmann::json& j, {{ cls.name }}::{{ enum.name }}& e) {
    const auto& name = j.get<std::string>();
{% for value in enum.enum_values %}
    {{ "if" if loop.first else "else if" }} (name == "{{ value }}") e = {{ cls.name }}::{{ enum.name }}::{{ value }};
{% endfor %}
    else {
        throw nlohmann::json::type_error::create(
            302,
            "Invalid enum value: '" + name + "' for type {{ cls.name }}::{{ enum.name }}",
            nullptr
        );
    }
}

{% endfor -%}
{% endif -%}
namespace webbridge {

// =============================================================================
// Static Validations
// =============================================================================

static_assert(impl::is_webbridge_object<{{ cls.name }}>,
              "{{ cls.name }} must derive from webbridge::object");

{% for prop in cls.properties -%}
// es ist die frage was das bringt
// static_assert(std::is_same_v<decltype({{ cls.name }}::{{ prop.name }}), object::property<{{ prop.type_name }}>>);
{% endfor -%}
{% for evt in cls.events -%}
static_assert(std::is_same_v<decltype({{ cls.name }}::{{ evt.name }}), object::event<{{ evt.arg_types | join(', ') }}>>);
{% endfor %}

// =============================================================================
// Type-specific Setup
// =============================================================================

namespace impl {

inline void setup_subscriptions(
    webview::webview& w_ref,
    const std::string& object_id,
    std::shared_ptr<{{ cls.name }}> obj)
{
    // Properties
{% for prop in cls.properties %}
    subscribe_property<{{ cls.name }}>(w_ref, object_id, "{{ prop.name }}", obj->{{ prop.name }});
{% endfor %}
    // Events
{% for evt in cls.events %}
    subscribe_event<{{ cls.name }}>(w_ref, object_id, "{{ evt.name }}", obj->{{ evt.name }});
{% endfor -%}
}

inline void bind_all(webview::webview& w_ref, object_registry& registry)
{
    // Property Getters
{% for prop in cls.properties %}
    bind_property_getter<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ prop.name }}", &{{ cls.name }}::{{ prop.name }});
{% endfor %}
    // Instance Constant Getters
{% for const in cls.constants if not const.is_static %}
    bind_instance_constant_getter<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ const.name }}", &{{ cls.name }}::{{ const.name }});
{% endfor %}
    // Static Constant Getters
{% for const in cls.constants if const.is_static %}
    bind_static_constant_getter<{{ cls.name }}>(w_ref, "{{ cls.name }}", "{{ const.name }}", {{ cls.name }}::{{ const.name }});
{% endfor %}
    // Sync Methods
{% for method in cls.sync_methods %}
    bind_sync_method<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ method.name }}", &{{ cls.name }}::{{ method.name }});
{% endfor %}
    // Async Methods
{% for method in cls.async_methods %}
    bind_async_method<{{ cls.name }}>(w_ref, registry, "{{ cls.name }}", "{{ method.name }}", &{{ cls.name }}::{{ method.name }});
{% endfor -%}
}

} // namespace impl

// =============================================================================
// Template Specializations
// =============================================================================

template<>
inline void register_type<{{ cls.name }}>(webview::webview* w) {
    webview::webview& w_ref = *w;
    using namespace impl;
    auto& registry = object_registry::instance();

    // JS initialization
    w_ref.init(generate_js_global_registry());
    w_ref.init(generate_js_class_wrapper(
        "{{ cls.name }}",
        {{ cls.sync_methods | json_names }},
        {{ cls.async_methods | json_names }},
        {{ cls.properties | json_names }},
        {{ cls.events | json_names }},
        {{ cls.constants | selectattr('is_static', 'false') | list | json_names }},
        {{ cls.constants | selectattr('is_static') | list | json_names }}
    ));

    // Object creation
    w_ref.bind("__create_{{ cls.name }}", [&registry, &w_ref](const std::string& req) -> std::string {
        auto obj = std::make_shared<{{ cls.name }}>();
        auto object_id = registry.register_object(obj, "{{ cls.name }}");
        impl::setup_subscriptions(w_ref, object_id, obj);
        return nlohmann::json(object_id).dump();
    });

    // Object destruction
    w_ref.bind("__webbridge_destroy", [&registry](const std::string& req) -> std::string {
        auto args = nlohmann::json::parse(req);
        registry.remove(extract_object_id(args));
        return "null";
    });

    // All bindings
    impl::bind_all(w_ref, registry);
}

template<>
inline void publish_object<{{ cls.name }}>(webview::webview* w, std::string_view name, std::shared_ptr<{{ cls.name }}> obj) {
    webview::webview& w_ref = *w;
    using namespace impl;
    auto& registry = object_registry::instance();
    auto object_id = registry.register_object(obj, "{{ cls.name }}");

    impl::setup_subscriptions(w_ref, object_id, obj);

    w_ref.init(generate_js_published_object(
        "{{ cls.name }}",
        std::string(name),
        object_id,
        {{ cls.sync_methods | json_names }},
        {{ cls.async_methods | json_names }},
        {{ cls.properties | json_names }},
        {{ cls.events | json_names }},
        {{ cls.constants | selectattr('is_static', 'false') | list | json_names }},
        {{ cls.constants | selectattr('is_static') | list | json_names }}
    ));
}

} // namespace webbridge