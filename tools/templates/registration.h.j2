#pragma once

/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 *
 * Generated by webbridge Registration Generator
 * Source: {{ header_path }}
 */

#include <nlohmann/json.hpp>
#include <chrono>
#include <iostream>
#include <thread>

#include "webbridge/impl/object_registry.h"
#include "webbridge/impl/type_registration.h"
#include "webbridge/impl/binding_helpers.h"
#include "{{ header_path }}"

{% if cls.enums -%}
// =============================================================================
// JSON Serialization for Nested Enums
// =============================================================================

{% for enum in cls.enums -%}
inline void to_json(nlohmann::json& j, const {{ cls.name }}::{{ enum.name }}& e) {
    switch (e) {
{% for value in enum.enum_values %}
        case {{ cls.name }}::{{ enum.name }}::{{ value }}: j = "{{ value }}"; break;
{% endfor %}
        default: j = nullptr; break;
    }
}

inline void from_json(const nlohmann::json& j, {{ cls.name }}::{{ enum.name }}& e) {
    const auto& name = j.get<std::string>();
{% for value in enum.enum_values %}
    {{ "if" if loop.first else "else if" }} (name == "{{ value }}") e = {{ cls.name }}::{{ enum.name }}::{{ value }};
{% endfor %}
    else {
        throw nlohmann::json::type_error::create(
            302,
            "Invalid enum value: '" + name + "' for type {{ cls.name }}::{{ enum.name }}",
            nullptr
        );
    }
}

{% endfor -%}
{% endif -%}
namespace webbridge {

// =============================================================================
// Static Validations
// =============================================================================

static_assert(impl::is_webbridge_object<{{ cls.name }}>,
              "{{ cls.name }} must derive from webbridge::object");


// =============================================================================
// Type-specific Setup
// =============================================================================

namespace impl {

inline void setup_subscriptions(
    webview::webview& w_ref,
    const std::string& object_id,
    {{ cls.name }}* obj)
{
{% for prop in cls.properties %}
    subscribe_property(w_ref, object_id, "{{ prop.name }}", obj->{{ prop.name }});
{% endfor %}
{% for evt in cls.events %}
    subscribe_event(w_ref, object_id, "{{ evt.name }}", obj->{{ evt.name }});
{% endfor -%}
}

// =============================================================================
// Consolidated Sync Binding Handler
// Protocol: [objectId, op, memberName, ...args]
//   op = "prop"  -> property getter
//   op = "const" -> instance constant getter
//   op = "call"  -> sync method call
// =============================================================================

inline void bind_{{ cls.name }}_sync(webview::webview& w_ref, object_registry& registry)
{
    w_ref.bind("__{{ cls.name }}_sync",
        [&registry](const std::string& req_id, const std::string& req, void* wPtr) {
            auto& w_ref = *static_cast<webview::webview*>(wPtr);
            auto args = nlohmann::json::parse(req);
            auto object_id = args.at(0).get<std::string>();
            auto op = args.at(1).get<std::string>();
            auto member = args.at(2).get<std::string>();
            auto obj = get_object_or_throw<{{ cls.name }}>(registry, object_id);

            if (op == "prop") {
{% for prop in cls.properties %}
                {{ "if" if loop.first else "} else if" }} (member == "{{ prop.name }}") {
                    w_ref.resolve(req_id, 0, nlohmann::json(obj->{{ prop.name }}()).dump());
                    return;
{% endfor %}
{% if cls.properties %}
                }
{% endif %}
            } else if (op == "const") {
{% for const in cls.constants if not const.is_static %}
                {{ "if" if loop.first else "} else if" }} (member == "{{ const.name }}") {
                    w_ref.resolve(req_id, 0, nlohmann::json(obj->{{ const.name }}).dump());
                    return;
{% endfor %}
{% if cls.constants | selectattr('is_static', 'false') | list %}
                }
{% endif %}
            } else if (op == "call") {
{% for method in cls.sync_methods %}
                {{ "if" if loop.first else "} else if" }} (member == "{{ method.name }}") {
                    auto [status, json] = invoke_and_serialize([&]() {
{% if method.parameters %}
                        return obj->{{ method.name }}(
{% for param in method.parameters %}
                            args.at({{ loop.index0 + 3 }}).get<{{ cls | qualified_type(param[0]) }}>(){% if not loop.last %},{% endif %}

{% endfor %}
                        );
{% else %}
                        return obj->{{ method.name }}();
{% endif %}
                    });
                    w_ref.resolve(req_id, status, json);
                    return;
{% endfor %}
{% if cls.sync_methods %}
                }
{% endif %}
            }
            // Unknown member/op
            w_ref.resolve(req_id, 1, R"({"error": "Unknown member or operation: )" + op + "/" + member + R"("})");
    }, &w_ref);
}

// =============================================================================
// Consolidated Async Binding Handler
// Protocol: [objectId, methodName, ...args]
// =============================================================================

inline void bind_{{ cls.name }}_async(webview::webview& w_ref, object_registry& registry)
{
{% if cls.async_methods %}
    w_ref.bind("__{{ cls.name }}_async",
        [&registry, &w_ref](const std::string& req_id, const std::string& req, void* w_ptr) {
            auto& w_ref = *static_cast<webview::webview*>(w_ptr);
            std::thread([&registry, &w_ref, req_id, req]() {
                auto args = nlohmann::json::parse(req);
                auto object_id = args.at(0).get<std::string>();
                auto method = args.at(1).get<std::string>();
                auto obj = get_object_or_throw<{{ cls.name }}>(registry, object_id);

{% for method in cls.async_methods %}
                {{ "if" if loop.first else "} else if" }} (method == "{{ method.name }}") {
                    auto [status, json] = invoke_and_serialize([&]() {
{% if method.parameters %}
                        return obj->{{ method.name }}(
{% for param in method.parameters %}
                            args.at({{ loop.index0 + 2 }}).get<{{ cls | qualified_type(param[0]) }}>(){% if not loop.last %},{% endif %}

{% endfor %}
                        );
{% else %}
                        return obj->{{ method.name }}();
{% endif %}
                    });
                    w_ref.resolve(req_id, status, json);
                    return;
{% endfor %}
                }
                // Unknown method
                w_ref.resolve(req_id, 1, R"({"error": "Unknown async method: )" + method + R"("})");
            }).detach();
        }, &w_ref);
{% else %}
    // No async methods - bind a no-op handler
    w_ref.bind("__{{ cls.name }}_async",
        [](const std::string& req_id, const std::string&, void* w_ptr) {
            auto& w_ref = *static_cast<webview::webview*>(w_ptr);
            w_ref.resolve(req_id, 1, R"({"error": "No async methods defined"})");
        }, &w_ref);
{% endif %}
}

} // namespace impl

// =============================================================================
// Template Specializations
// =============================================================================

template<>
inline void register_type<{{ cls.name }}>(webview::webview* w) {
    webview::webview& w_ref = *w;
    using namespace impl;
    auto& registry = object_registry::instance();

    // Initialize webview (once per webview instance)
    init_webview(w, [&registry](const std::string& object_id) {
        registry.remove(object_id);
    });

    // Static constants as JSON object
    nlohmann::json static_consts = nlohmann::json::object();
{% for const in cls.constants if const.is_static %}
    static_consts["{{ const.name }}"] = {{ cls.name }}::{{ const.name }};
{% endfor %}

    // JS class initialization
    w_ref.init(generate_js_class_wrapper(
        "{{ cls.name }}",
        {{ cls.sync_methods | json_names }},
        {{ cls.async_methods | json_names }},
        {{ cls.properties | json_names }},
        {{ cls.events | json_names }},
        {{ cls.constants | selectattr('is_static', 'false') | list | json_names }},
        static_consts
    ));

    // Object creation binding
{% set ctor = cls.constructors[0] if cls.constructors else none %}
    w_ref.bind("__create_{{ cls.name }}", [&registry, &w_ref](const std::string& req) -> std::string {
{% if ctor and ctor.parameters %}
        auto args = nlohmann::json::parse(req);
        auto obj = std::make_shared<{{ cls.name }}>(
{% for param in ctor.parameters %}
            args[{{ loop.index0 }}].get<{{ cls | qualified_type(param[0]) }}>(){% if not loop.last %},{% endif %}

{% endfor %}
        );
{% else %}
        auto obj = std::make_shared<{{ cls.name }}>();
{% endif %}
        auto object_id = registry.register_object(obj, "{{ cls.name }}");
        impl::setup_subscriptions(w_ref, object_id, obj.get());
        return nlohmann::json(object_id).dump();
    });

    // Consolidated bindings (sync + async)
    impl::bind_{{ cls.name }}_sync(w_ref, registry);
    impl::bind_{{ cls.name }}_async(w_ref, registry);
}

} // namespace webbridge
